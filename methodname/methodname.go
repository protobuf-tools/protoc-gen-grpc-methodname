// SPDX-FileCopyrightText: Copyright 2022 The protobuf-tools Authors
// SPDX-License-Identifier: BSD-3-Clause

// Package methodname generates gRPC full method name constants.
package methodname

import (
	"fmt"
	"path"
	"sort"
	"strconv"

	"google.golang.org/protobuf/compiler/protogen"
)

var version = "devel"

// Method represents a generated RPC method.
type Method struct {
	GoName      string
	IsStreaming bool
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}

	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}

	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

// GenerateFile generates RPC service proxy from .pb.go types.
func GenerateFile(p *protogen.Plugin, f *protogen.File) *protogen.GeneratedFile {
	if len(f.Services) == 0 {
		return nil
	}

	filename := f.GeneratedFilenamePrefix + "_grpc_method.pb.go"
	g := p.NewGeneratedFile(filename, f.GoImportPath)

	g.P("// Code generated by protoc-gen-grpc-methodname. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-grpc-methodname ", version)
	g.P("// - protoc           ", protocVersion(p))
	if f.Proto.GetOptions().GetDeprecated() {
		g.P("// Deprecated: ", f.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", f.Desc.Path())
	}
	g.P()
	g.P(`package `, f.GoPackageName)
	g.P()

	services := f.Services
	for i, service := range services {
		sort.Slice(services[i].Methods, func(j, k int) bool { return services[i].Methods[j].GoName < services[i].Methods[k].GoName })

		g.P(`const (`)
		for _, method := range service.Methods {
			g.P(`	FullMethod`, method.GoName, ` = `, strconv.Quote(path.Join("/"+string(service.Desc.FullName()), string(method.Desc.Name()))))
		}
		g.P(`)`)
	}

	return g
}
